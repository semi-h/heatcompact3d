var tipuesearch = {"pages":[{"title":" heatcompact3d ","text":"heatcompact3d A 3D heat equation solver based on 6th order compact finite\ndifferences schemes. Developer Info Thibault Lestang","tags":"home","loc":"index.html"},{"title":"field_type – heatcompact3d ","text":"type, public :: field_type Implement a 3D scalar field, for instance a temperature field. type ( field_type ) = afield real :: u0 ( nx , ny , nz ), dx afield = field_type ( u0 , dx ) Contents Constructor field_type Type-Bound Procedures nz ny nx dump rhs is_equal operator(+) operator(-) operator(*) Constructor public        interface field_type public  function field_constructor (initial, dx) result(afield) Arguments Type Intent Optional Attributes Name real, intent(in) :: initial (:,:,:) Initial state real, intent(in) :: dx Spatial mesh spacing Return Value type( field_type ) Type-Bound Procedures procedure, public :: nz public pure function nz (self) Returns domain size in direction Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Return Value integer procedure, public :: ny public pure function ny (self) Returns domain size in direction Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Return Value integer procedure, public :: nx public pure function nx (self) Returns domain size in direction Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Return Value integer procedure, public :: dump public  subroutine dump (self, file_path, fmt) Write field data to ASCII file Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self character, intent(in) :: file_path Relative path to file to output file character, optional :: fmt Format string procedure, public :: rhs public pure function rhs (self) Evaluates right hand side of heat equation on a field instance. Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Return Value type( field_type ) procedure, public :: is_equal public pure function is_equal (self, lhs, tol) Compare two field_type instance based on their data value f1 = field_type ( u0 , dx ) f2 = field_type ( u0 , dx2 ) f1 % is_equal ( f2 ) ! true Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Right hand side of comparison class( field_type ), intent(in) :: lhs Left hand side of comparison real, intent(in) :: tol Absolute tolerance when comparing\nfields values Return Value logical generic, public :: operator(+) => field_add_field public pure function field_add_field (self, afield) Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self class( field_type ), intent(in) :: afield Return Value type( field_type ) generic, public :: operator(-) => field_sub_field public pure function field_sub_field (self, afield) Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self class( field_type ), intent(in) :: afield Return Value type( field_type ) generic, public :: operator(*) => field_mul_real public pure function field_mul_real (self, a) Multiply a field_type instance by a real number. f1 = field_type(u0, dx)\nf2 = f1 * 1.3\nf2%is_equal(field_type(u0 * 1.3, dx)) ! true Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Left hand side real, intent(in) :: a Scalar to multiply field instance with Return Value type( field_type )","tags":"","loc":"type/field_type.html"},{"title":"differentiator_type – heatcompact3d ","text":"type, public :: differentiator_type Implements differentiation over a periodic stencil. differentiator_type provides access a a unique type-bound\nprocedure diff Contents Type-Bound Procedures diff Type-Bound Procedures procedure, public :: diff => diff_periodic public pure function diff_periodic (self, f, dx) result(df) Apply a differentiation stencil along a one dimensional pencil,\nassuming periodic boundaries. For instance, with a four point\nstencil and weights Arguments Type Intent Optional Attributes Name class( differentiator_type ), intent(in) :: self real, intent(in) :: f (:) Function to be derive, evaluated on pencil real, intent(in) :: dx Step size Return Value real, allocatable, (:) Derivative, evaluated on pencil","tags":"","loc":"type/differentiator_type.html"},{"title":"nonperiodic_differentiator_type – heatcompact3d ","text":"type, public, extends( differentiator_type ) :: nonperiodic_differentiator_type Contents Variables east_stencils west_stencils Type-Bound Procedures diff Components Type Visibility Attributes Name Initial type( stencil_type ), public :: east_stencils (2) type( stencil_type ), public :: west_stencils (2) Type-Bound Procedures procedure, public :: diff => diff_nonperiodic public pure function diff_nonperiodic (self, f, dx) result(df) Apply a differentiation stencil along a one dimensional pencil,\nthen apply boundary conditions on both ends. Boundary\nconditions are applied as arrays of type stencil_type Arguments Type Intent Optional Attributes Name class( nonperiodic_differentiator_type ), intent(in) :: self real, intent(in) :: f (:) real, intent(in) :: dx Return Value real, allocatable, (:)","tags":"","loc":"type/nonperiodic_differentiator_type.html"},{"title":"time_integrator_type – heatcompact3d ","text":"type, public, abstract :: time_integrator_type Contents Variables starttime endtime dt Type-Bound Procedures integrate Components Type Visibility Attributes Name Initial real, public :: starttime real, public :: endtime real, public :: dt Type-Bound Procedures procedure( integrate_proc ), public, deferred :: integrate subroutine integrate_proc(self, afield) Prototype Arguments Type Intent Optional Attributes Name class( time_integrator_type ), intent(in) :: self type( field_type ), intent(inout) :: afield","tags":"","loc":"type/time_integrator_type.html"},{"title":"euler_integrator_type – heatcompact3d ","text":"type, public, extends( time_integrator_type ) :: euler_integrator_type Contents Variables starttime endtime dt alpha Type-Bound Procedures integrate Components Type Visibility Attributes Name Initial real, public :: starttime real, public :: endtime real, public :: dt real, public :: alpha = 1. Type-Bound Procedures procedure, public :: integrate => integrate_euler public  subroutine integrate_euler (self, afield) Arguments Type Intent Optional Attributes Name class( euler_integrator_type ), intent(in) :: self type( field_type ), intent(inout) :: afield","tags":"","loc":"type/euler_integrator_type.html"},{"title":"AB2_integrator_type – heatcompact3d ","text":"type, public, extends( time_integrator_type ) :: AB2_integrator_type Contents Variables starttime endtime dt Type-Bound Procedures integrate Components Type Visibility Attributes Name Initial real, public :: starttime real, public :: endtime real, public :: dt Type-Bound Procedures procedure, public :: integrate => integrate_AB2 public  subroutine integrate_AB2 (self, afield) Arguments Type Intent Optional Attributes Name class( AB2_integrator_type ), intent(in) :: self type( field_type ), intent(inout) :: afield","tags":"","loc":"type/ab2_integrator_type.html"},{"title":"RK3_integrator_type – heatcompact3d ","text":"type, public, extends( time_integrator_type ) :: RK3_integrator_type Contents Variables starttime endtime dt Type-Bound Procedures integrate Components Type Visibility Attributes Name Initial real, public :: starttime real, public :: endtime real, public :: dt Type-Bound Procedures procedure, public :: integrate => integrate_RK3 public  subroutine integrate_RK3 (self, afield) Arguments Type Intent Optional Attributes Name class( RK3_integrator_type ), intent(in) :: self type( field_type ), intent(inout) :: afield","tags":"","loc":"type/rk3_integrator_type.html"},{"title":"boundary_type – heatcompact3d ","text":"type, public :: boundary_type Contents Variables first_order_east second_order_east first_order_west second_order_west Components Type Visibility Attributes Name Initial type( stencil_type ), public :: first_order_east (2) type( stencil_type ), public :: second_order_east (2) type( stencil_type ), public :: first_order_west (2) type( stencil_type ), public :: second_order_west (2)","tags":"","loc":"type/boundary_type.html"},{"title":"stencil_type – heatcompact3d ","text":"type, public :: stencil_type Contents Variables nodes coeffs lower upper Type-Bound Procedures apply apply_along get_lower get_upper is_equal flip operator(*) Components Type Visibility Attributes Name Initial integer, public, allocatable :: nodes (:) real, public, allocatable :: coeffs (:) real, public :: lower real, public :: upper Type-Bound Procedures procedure, public :: apply => apply_stencil public pure function apply_stencil (self, f, ref) Arguments Type Intent Optional Attributes Name class( stencil_type ), intent(in) :: self real, intent(in) :: f (:) integer, intent(in) :: ref Return Value real procedure, public :: apply_along => apply_stencil_along public pure function apply_stencil_along (self, f) Arguments Type Intent Optional Attributes Name class( stencil_type ), intent(in) :: self real, intent(in) :: f (:) Return Value real, allocatable, (:) procedure, public :: get_lower public pure elemental function get_lower (self) Arguments Type Intent Optional Attributes Name class( stencil_type ), intent(in) :: self Return Value real procedure, public :: get_upper public pure elemental function get_upper (self) Arguments Type Intent Optional Attributes Name class( stencil_type ), intent(in) :: self Return Value real procedure, public :: is_equal public pure function is_equal (self, st, tol) Arguments Type Intent Optional Attributes Name class( stencil_type ), intent(in) :: self type( stencil_type ), intent(in) :: st real, intent(in) :: tol Return Value logical procedure, public :: flip public pure elemental function flip (self) Arguments Type Intent Optional Attributes Name class( stencil_type ), intent(in) :: self Return Value type( stencil_type ) generic, public :: operator(*) => stencil_mul_real public pure elemental function stencil_mul_real (self, a) Arguments Type Intent Optional Attributes Name class( stencil_type ), intent(in) :: self real, intent(in) :: a Return Value type( stencil_type )","tags":"","loc":"type/stencil_type.html"},{"title":"integrate_proc – heatcompact3d","text":"abstract interface public  subroutine integrate_proc(self, afield) Arguments Type Intent Optional Attributes Name class( time_integrator_type ), intent(in) :: self type( field_type ), intent(inout) :: afield","tags":"","loc":"interface/integrate_proc.html"},{"title":"field_constructor – heatcompact3d","text":"public  function field_constructor(initial, dx) result(afield) Arguments Type Intent Optional Attributes Name real, intent(in) :: initial (:,:,:) Initial state real, intent(in) :: dx Spatial mesh spacing Return Value type( field_type ) Contents","tags":"","loc":"proc/field_constructor.html"},{"title":"nx – heatcompact3d","text":"public pure function nx(self) Returns domain size in direction Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Return Value integer Contents","tags":"","loc":"proc/nx.html"},{"title":"ny – heatcompact3d","text":"public pure function ny(self) Returns domain size in direction Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Return Value integer Contents","tags":"","loc":"proc/ny.html"},{"title":"nz – heatcompact3d","text":"public pure function nz(self) Returns domain size in direction Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Return Value integer Contents","tags":"","loc":"proc/nz.html"},{"title":"is_equal – heatcompact3d","text":"public pure function is_equal(self, lhs, tol) Compare two field_type instance based on their data value f1 = field_type ( u0 , dx ) f2 = field_type ( u0 , dx2 ) f1 % is_equal ( f2 ) ! true Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Right hand side of comparison class( field_type ), intent(in) :: lhs Left hand side of comparison real, intent(in) :: tol Absolute tolerance when comparing\nfields values Return Value logical Contents","tags":"","loc":"proc/is_equal.html"},{"title":"rhs – heatcompact3d","text":"public pure function rhs(self) Uses differentiate Evaluates right hand side of heat equation on a field instance. Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Return Value type( field_type ) Contents","tags":"","loc":"proc/rhs.html"},{"title":"field_add_field – heatcompact3d","text":"public pure function field_add_field(self, afield) Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self class( field_type ), intent(in) :: afield Return Value type( field_type ) Contents","tags":"","loc":"proc/field_add_field.html"},{"title":"field_sub_field – heatcompact3d","text":"public pure function field_sub_field(self, afield) Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self class( field_type ), intent(in) :: afield Return Value type( field_type ) Contents","tags":"","loc":"proc/field_sub_field.html"},{"title":"field_mul_real – heatcompact3d","text":"public pure function field_mul_real(self, a) Multiply a field_type instance by a real number. f1 = field_type(u0, dx)\nf2 = f1 * 1.3\nf2%is_equal(field_type(u0 * 1.3, dx)) ! true Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Left hand side real, intent(in) :: a Scalar to multiply field instance with Return Value type( field_type ) Contents","tags":"","loc":"proc/field_mul_real.html"},{"title":"dump – heatcompact3d","text":"public  subroutine dump(self, file_path, fmt) Write field data to ASCII file Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self character, intent(in) :: file_path Relative path to file to output file character, optional :: fmt Format string Contents","tags":"","loc":"proc/dump.html"},{"title":"field_type – heatcompact3d","text":"public interface field_type Contents Module Procedures field_constructor Module Procedures public  function field_constructor (initial, dx) result(afield) Arguments Type Intent Optional Attributes Name real, intent(in) :: initial (:,:,:) Initial state real, intent(in) :: dx Spatial mesh spacing Return Value type( field_type )","tags":"","loc":"interface/field_type.html"},{"title":"sixth_order_compact_1_nonperiodic – heatcompact3d","text":"public pure function sixth_order_compact_1_nonperiodic(east, west) Arguments Type Intent Optional Attributes Name type( boundary_type ), intent(in) :: east type( boundary_type ), intent(in) :: west Return Value type( nonperiodic_differentiator_type ) Contents","tags":"","loc":"proc/sixth_order_compact_1_nonperiodic.html"},{"title":"sixth_order_compact_1_periodic – heatcompact3d","text":"public pure function sixth_order_compact_1_periodic() Arguments None Return Value type( differentiator_type ) Contents None","tags":"","loc":"proc/sixth_order_compact_1_periodic.html"},{"title":"sixth_order_compact_2_nonperiodic – heatcompact3d","text":"public pure function sixth_order_compact_2_nonperiodic(east, west) Arguments Type Intent Optional Attributes Name type( boundary_type ), intent(in) :: east type( boundary_type ), intent(in) :: west Return Value type( nonperiodic_differentiator_type ) Contents","tags":"","loc":"proc/sixth_order_compact_2_nonperiodic.html"},{"title":"sixth_order_compact_2_periodic – heatcompact3d","text":"public pure function sixth_order_compact_2_periodic() Arguments None Return Value type( differentiator_type ) Contents None","tags":"","loc":"proc/sixth_order_compact_2_periodic.html"},{"title":"diff_nonperiodic – heatcompact3d","text":"public pure function diff_nonperiodic(self, f, dx) result(df) Apply a differentiation stencil along a one dimensional pencil,\nthen apply boundary conditions on both ends. Boundary\nconditions are applied as arrays of type stencil_type Arguments Type Intent Optional Attributes Name class( nonperiodic_differentiator_type ), intent(in) :: self real, intent(in) :: f (:) real, intent(in) :: dx Return Value real, allocatable, (:) Contents","tags":"","loc":"proc/diff_nonperiodic.html"},{"title":"diff_periodic – heatcompact3d","text":"public pure function diff_periodic(self, f, dx) result(df) Apply a differentiation stencil along a one dimensional pencil,\nassuming periodic boundaries. For instance, with a four point\nstencil and weights Arguments Type Intent Optional Attributes Name class( differentiator_type ), intent(in) :: self real, intent(in) :: f (:) Function to be derive, evaluated on pencil real, intent(in) :: dx Step size Return Value real, allocatable, (:) Derivative, evaluated on pencil Contents","tags":"","loc":"proc/diff_periodic.html"},{"title":"reverse – heatcompact3d","text":"public pure function reverse(x) Arguments Type Intent Optional Attributes Name real, intent(in) :: x (:) Return Value real, allocatable, (:) Contents","tags":"","loc":"proc/reverse.html"},{"title":"sixth_order_compact_1 – heatcompact3d","text":"public interface sixth_order_compact_1 Contents Module Procedures sixth_order_compact_1_periodic sixth_order_compact_1_nonperiodic Module Procedures public pure function sixth_order_compact_1_periodic () Arguments None Return Value type( differentiator_type ) public pure function sixth_order_compact_1_nonperiodic (east, west) Arguments Type Intent Optional Attributes Name type( boundary_type ), intent(in) :: east type( boundary_type ), intent(in) :: west Return Value type( nonperiodic_differentiator_type )","tags":"","loc":"interface/sixth_order_compact_1.html"},{"title":"sixth_order_compact_2 – heatcompact3d","text":"public interface sixth_order_compact_2 Contents Module Procedures sixth_order_compact_2_periodic sixth_order_compact_2_nonperiodic Module Procedures public pure function sixth_order_compact_2_periodic () Arguments None Return Value type( differentiator_type ) public pure function sixth_order_compact_2_nonperiodic (east, west) Arguments Type Intent Optional Attributes Name type( boundary_type ), intent(in) :: east type( boundary_type ), intent(in) :: west Return Value type( nonperiodic_differentiator_type )","tags":"","loc":"interface/sixth_order_compact_2.html"},{"title":"euler_timestep – heatcompact3d","text":"public pure function euler_timestep(afield, dt) result(res) Arguments Type Intent Optional Attributes Name type( field_type ), intent(in) :: afield real, intent(in) :: dt Return Value type( field_type ) Contents","tags":"","loc":"proc/euler_timestep.html"},{"title":"AB2_timestep – heatcompact3d","text":"public pure function AB2_timestep(fields, dt) result(res) Arguments Type Intent Optional Attributes Name type( field_type ), intent(in) :: fields (2) real, intent(in) :: dt Return Value type( field_type ), (2) Contents","tags":"","loc":"proc/ab2_timestep.html"},{"title":"integrate_euler – heatcompact3d","text":"public  subroutine integrate_euler(self, afield) Arguments Type Intent Optional Attributes Name class( euler_integrator_type ), intent(in) :: self type( field_type ), intent(inout) :: afield Contents","tags":"","loc":"proc/integrate_euler.html"},{"title":"integrate_AB2 – heatcompact3d","text":"public  subroutine integrate_AB2(self, afield) Arguments Type Intent Optional Attributes Name class( AB2_integrator_type ), intent(in) :: self type( field_type ), intent(inout) :: afield Contents","tags":"","loc":"proc/integrate_ab2.html"},{"title":"integrate_RK3 – heatcompact3d","text":"public  subroutine integrate_RK3(self, afield) Arguments Type Intent Optional Attributes Name class( RK3_integrator_type ), intent(in) :: self type( field_type ), intent(inout) :: afield Contents","tags":"","loc":"proc/integrate_rk3.html"},{"title":"sixth_order_compact_stencil – heatcompact3d","text":"public pure function sixth_order_compact_stencil() Arguments None Return Value type( stencil_type ) Contents None","tags":"","loc":"proc/sixth_order_compact_stencil.html"},{"title":"sixth_order_compact_second_stencil – heatcompact3d","text":"public pure function sixth_order_compact_second_stencil() Arguments None Return Value type( stencil_type ) Contents None","tags":"","loc":"proc/sixth_order_compact_second_stencil.html"},{"title":"get_dirichlet_boundary – heatcompact3d","text":"public  function get_dirichlet_boundary() Arguments None Return Value type( boundary_type ) Contents None","tags":"","loc":"proc/get_dirichlet_boundary.html"},{"title":"is_equal – heatcompact3d","text":"public pure function is_equal(self, st, tol) Arguments Type Intent Optional Attributes Name class( stencil_type ), intent(in) :: self type( stencil_type ), intent(in) :: st real, intent(in) :: tol Return Value logical Contents","tags":"","loc":"proc/is_equal~2.html"},{"title":"stencil_mul_real – heatcompact3d","text":"public pure elemental function stencil_mul_real(self, a) Arguments Type Intent Optional Attributes Name class( stencil_type ), intent(in) :: self real, intent(in) :: a Return Value type( stencil_type ) Contents","tags":"","loc":"proc/stencil_mul_real.html"},{"title":"flip – heatcompact3d","text":"public pure elemental function flip(self) Arguments Type Intent Optional Attributes Name class( stencil_type ), intent(in) :: self Return Value type( stencil_type ) Contents","tags":"","loc":"proc/flip.html"},{"title":"get_upper – heatcompact3d","text":"public pure elemental function get_upper(self) Arguments Type Intent Optional Attributes Name class( stencil_type ), intent(in) :: self Return Value real Contents","tags":"","loc":"proc/get_upper.html"},{"title":"get_lower – heatcompact3d","text":"public pure elemental function get_lower(self) Arguments Type Intent Optional Attributes Name class( stencil_type ), intent(in) :: self Return Value real Contents","tags":"","loc":"proc/get_lower.html"},{"title":"apply_stencil – heatcompact3d","text":"public pure function apply_stencil(self, f, ref) Arguments Type Intent Optional Attributes Name class( stencil_type ), intent(in) :: self real, intent(in) :: f (:) integer, intent(in) :: ref Return Value real Contents","tags":"","loc":"proc/apply_stencil.html"},{"title":"apply_stencil_along – heatcompact3d","text":"public pure function apply_stencil_along(self, f) Arguments Type Intent Optional Attributes Name class( stencil_type ), intent(in) :: self real, intent(in) :: f (:) Return Value real, allocatable, (:) Contents","tags":"","loc":"proc/apply_stencil_along.html"},{"title":"thomas – heatcompact3d","text":"public pure function thomas(as, bs, cs, ds) result(x) Arguments Type Intent Optional Attributes Name real, intent(in) :: as (:) real, intent(in) :: bs (:) real, intent(in) :: cs (:) real, intent(in) :: ds (:) Return Value real, allocatable, (:) Contents","tags":"","loc":"proc/thomas.html"},{"title":"field – heatcompact3d","text":"Contents Interfaces field_type Derived Types field_type Functions field_constructor nx ny nz is_equal rhs field_add_field field_sub_field field_mul_real Subroutines dump Interfaces public        interface field_type public  function field_constructor (initial, dx) result(afield) Arguments Type Intent Optional Attributes Name real, intent(in) :: initial (:,:,:) Initial state real, intent(in) :: dx Spatial mesh spacing Return Value type( field_type ) Derived Types type, public :: field_type Implement a 3D scalar field, for instance a temperature field. Read more… Constructor public\n\n                    \n                    function field_constructor (initial, dx) Type-Bound Procedures procedure\n                    ,                  public\n                  :: nz Function procedure\n                    ,                  public\n                  :: ny Function procedure\n                    ,                  public\n                  :: nx Function procedure\n                    ,                  public\n                  :: dump Subroutine procedure\n                    ,                  public\n                  :: rhs Function procedure\n                    ,                  public\n                  :: is_equal Function generic,\n                  public\n                  :: operator(+) =>\n                    field_add_field generic,\n                  public\n                  :: operator(-) =>\n                    field_sub_field generic,\n                  public\n                  :: operator(*) =>\n                    field_mul_real Functions public  function field_constructor (initial, dx) result(afield) Arguments Type Intent Optional Attributes Name real, intent(in) :: initial (:,:,:) Initial state real, intent(in) :: dx Spatial mesh spacing Return Value type( field_type ) public pure function nx (self) Returns domain size in direction Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Return Value integer public pure function ny (self) Returns domain size in direction Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Return Value integer public pure function nz (self) Returns domain size in direction Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Return Value integer public pure function is_equal (self, lhs, tol) Compare two field_type instance based on their data value Read more… Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Right hand side of comparison class( field_type ), intent(in) :: lhs Left hand side of comparison real, intent(in) :: tol Absolute tolerance when comparing\nfields values Return Value logical public pure function rhs (self) Evaluates right hand side of heat equation on a field instance. Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Return Value type( field_type ) public pure function field_add_field (self, afield) Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self class( field_type ), intent(in) :: afield Return Value type( field_type ) public pure function field_sub_field (self, afield) Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self class( field_type ), intent(in) :: afield Return Value type( field_type ) public pure function field_mul_real (self, a) Multiply a field_type instance by a real number. Read more… Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self Left hand side real, intent(in) :: a Scalar to multiply field instance with Return Value type( field_type ) Subroutines public  subroutine dump (self, file_path, fmt) Write field data to ASCII file Arguments Type Intent Optional Attributes Name class( field_type ), intent(in) :: self character, intent(in) :: file_path Relative path to file to output file character, optional :: fmt Format string","tags":"","loc":"module/field.html"},{"title":"differentiate – heatcompact3d","text":"This module implements differentiation over a one dimensional\npencil.  It exports concrete derived types differentiator_type :: periodic differentiation nonperiodic_differentiator_type :: non periodic differentiation Both types provide access to a single type-procedure diff that\nperforms the differentiation and return the derivative evaluated\nover the input pencil. Instances of differentiator derived types are created on the\nclient side via constructor procedures <method>_<order> (e.g. sixth_order_compact_1 ). These constructor procedures are\nimplemented as a generic interface to concrete constructors for\nthe periodic case (no boundary conditions are specified) or the\nnoneriodic case (boundary conditions are specified). See module boundary_schemes . use boundary_schemes, only:: get_dirichlet_4th\nreal :: f(:), df(:), dx\n! ...\n! ...\ndifferentiatior = sixth_order_compact_1( &\n     & east = get_dirichlet_4th(), &\n     & west = get_dirichlet_4th(), &\n     & )\ndf = differentiatior%diff(f, dx) Uses boundary_schemes stencil thomas_module Contents Interfaces sixth_order_compact_1 sixth_order_compact_2 Derived Types differentiator_type nonperiodic_differentiator_type Functions sixth_order_compact_1_nonperiodic sixth_order_compact_1_periodic sixth_order_compact_2_nonperiodic sixth_order_compact_2_periodic diff_nonperiodic diff_periodic reverse Interfaces public        interface sixth_order_compact_1 public pure function sixth_order_compact_1_periodic () Arguments None Return Value type( differentiator_type ) public pure function sixth_order_compact_1_nonperiodic (east, west) Arguments Type Intent Optional Attributes Name type( boundary_type ), intent(in) :: east type( boundary_type ), intent(in) :: west Return Value type( nonperiodic_differentiator_type ) public        interface sixth_order_compact_2 public pure function sixth_order_compact_2_periodic () Arguments None Return Value type( differentiator_type ) public pure function sixth_order_compact_2_nonperiodic (east, west) Arguments Type Intent Optional Attributes Name type( boundary_type ), intent(in) :: east type( boundary_type ), intent(in) :: west Return Value type( nonperiodic_differentiator_type ) Derived Types type, public :: differentiator_type Implements differentiation over a periodic stencil. differentiator_type provides access a a unique type-bound\nprocedure diff Type-Bound Procedures procedure\n                    ,                  public\n                  :: diff => diff_periodic Function type, public, extends( differentiator_type ) :: nonperiodic_differentiator_type Components Type Visibility Attributes Name Initial type( stencil_type ), public :: east_stencils (2) type( stencil_type ), public :: west_stencils (2) Type-Bound Procedures procedure\n                    ,                  public\n                  :: diff => diff_nonperiodic Function Functions public pure function sixth_order_compact_1_nonperiodic (east, west) Arguments Type Intent Optional Attributes Name type( boundary_type ), intent(in) :: east type( boundary_type ), intent(in) :: west Return Value type( nonperiodic_differentiator_type ) public pure function sixth_order_compact_1_periodic () Arguments None Return Value type( differentiator_type ) public pure function sixth_order_compact_2_nonperiodic (east, west) Arguments Type Intent Optional Attributes Name type( boundary_type ), intent(in) :: east type( boundary_type ), intent(in) :: west Return Value type( nonperiodic_differentiator_type ) public pure function sixth_order_compact_2_periodic () Arguments None Return Value type( differentiator_type ) public pure function diff_nonperiodic (self, f, dx) result(df) Apply a differentiation stencil along a one dimensional pencil,\nthen apply boundary conditions on both ends. Boundary\nconditions are applied as arrays of type stencil_type Arguments Type Intent Optional Attributes Name class( nonperiodic_differentiator_type ), intent(in) :: self real, intent(in) :: f (:) real, intent(in) :: dx Return Value real, allocatable, (:) public pure function diff_periodic (self, f, dx) result(df) Apply a differentiation stencil along a one dimensional pencil,\nassuming periodic boundaries. For instance, with a four point\nstencil and weights Read more… Arguments Type Intent Optional Attributes Name class( differentiator_type ), intent(in) :: self real, intent(in) :: f (:) Function to be derive, evaluated on pencil real, intent(in) :: dx Step size Return Value real, allocatable, (:) Derivative, evaluated on pencil public pure function reverse (x) Arguments Type Intent Optional Attributes Name real, intent(in) :: x (:) Return Value real, allocatable, (:)","tags":"","loc":"module/differentiate.html"},{"title":"time_integrator – heatcompact3d","text":"Uses field Contents Abstract Interfaces integrate_proc Derived Types time_integrator_type euler_integrator_type AB2_integrator_type RK3_integrator_type Functions euler_timestep AB2_timestep Subroutines integrate_euler integrate_AB2 integrate_RK3 Abstract Interfaces abstract interface public  subroutine integrate_proc(self, afield) Arguments Type Intent Optional Attributes Name class( time_integrator_type ), intent(in) :: self type( field_type ), intent(inout) :: afield Derived Types type, public :: time_integrator_type Components Type Visibility Attributes Name Initial real, public :: starttime real, public :: endtime real, public :: dt Type-Bound Procedures procedure\n(integrate_proc)                    ,                  public\n                  :: integrate type, public, extends( time_integrator_type ) :: euler_integrator_type Components Type Visibility Attributes Name Initial real, public :: starttime real, public :: endtime real, public :: dt real, public :: alpha = 1. Type-Bound Procedures procedure\n                    ,                  public\n                  :: integrate => integrate_euler Subroutine type, public, extends( time_integrator_type ) :: AB2_integrator_type Components Type Visibility Attributes Name Initial real, public :: starttime real, public :: endtime real, public :: dt Type-Bound Procedures procedure\n                    ,                  public\n                  :: integrate => integrate_AB2 Subroutine type, public, extends( time_integrator_type ) :: RK3_integrator_type Components Type Visibility Attributes Name Initial real, public :: starttime real, public :: endtime real, public :: dt Type-Bound Procedures procedure\n                    ,                  public\n                  :: integrate => integrate_RK3 Subroutine Functions public pure function euler_timestep (afield, dt) result(res) Arguments Type Intent Optional Attributes Name type( field_type ), intent(in) :: afield real, intent(in) :: dt Return Value type( field_type ) public pure function AB2_timestep (fields, dt) result(res) Arguments Type Intent Optional Attributes Name type( field_type ), intent(in) :: fields (2) real, intent(in) :: dt Return Value type( field_type ), (2) Subroutines public  subroutine integrate_euler (self, afield) Arguments Type Intent Optional Attributes Name class( euler_integrator_type ), intent(in) :: self type( field_type ), intent(inout) :: afield public  subroutine integrate_AB2 (self, afield) Arguments Type Intent Optional Attributes Name class( AB2_integrator_type ), intent(in) :: self type( field_type ), intent(inout) :: afield public  subroutine integrate_RK3 (self, afield) Arguments Type Intent Optional Attributes Name class( RK3_integrator_type ), intent(in) :: self type( field_type ), intent(inout) :: afield","tags":"","loc":"module/time_integrator.html"},{"title":"boundary_schemes – heatcompact3d","text":"Uses stencil Contents Variables sixth_order_compact_coeffs sixth_order_compact_coeffs_2 Derived Types boundary_type Functions sixth_order_compact_stencil sixth_order_compact_second_stencil get_dirichlet_boundary Variables Type Visibility Attributes Name Initial real, public, parameter :: sixth_order_compact_coeffs (4) = [-1./36., -7./9., +7./9., +1./36.] real, public, parameter :: sixth_order_compact_coeffs_2 (5) = [3./44., 12./11., -2.*(12./11.+3./44.), 12./11., 3./44.] Derived Types type, public :: boundary_type Components Type Visibility Attributes Name Initial type( stencil_type ), public :: first_order_east (2) type( stencil_type ), public :: second_order_east (2) type( stencil_type ), public :: first_order_west (2) type( stencil_type ), public :: second_order_west (2) Functions public pure function sixth_order_compact_stencil () Arguments None Return Value type( stencil_type ) public pure function sixth_order_compact_second_stencil () Arguments None Return Value type( stencil_type ) public  function get_dirichlet_boundary () Arguments None Return Value type( boundary_type )","tags":"","loc":"module/boundary_schemes.html"},{"title":"stencil – heatcompact3d","text":"Contents Derived Types stencil_type Functions is_equal stencil_mul_real flip get_upper get_lower apply_stencil apply_stencil_along Derived Types type, public :: stencil_type Components Type Visibility Attributes Name Initial integer, public, allocatable :: nodes (:) real, public, allocatable :: coeffs (:) real, public :: lower real, public :: upper Type-Bound Procedures procedure\n                    ,                  public\n                  :: apply => apply_stencil Function procedure\n                    ,                  public\n                  :: apply_along => apply_stencil_along Function procedure\n                    ,                  public\n                  :: get_lower Function procedure\n                    ,                  public\n                  :: get_upper Function procedure\n                    ,                  public\n                  :: is_equal Function procedure\n                    ,                  public\n                  :: flip Function generic,\n                  public\n                  :: operator(*) =>\n                    stencil_mul_real Functions public pure function is_equal (self, st, tol) Arguments Type Intent Optional Attributes Name class( stencil_type ), intent(in) :: self type( stencil_type ), intent(in) :: st real, intent(in) :: tol Return Value logical public pure elemental function stencil_mul_real (self, a) Arguments Type Intent Optional Attributes Name class( stencil_type ), intent(in) :: self real, intent(in) :: a Return Value type( stencil_type ) public pure elemental function flip (self) Arguments Type Intent Optional Attributes Name class( stencil_type ), intent(in) :: self Return Value type( stencil_type ) public pure elemental function get_upper (self) Arguments Type Intent Optional Attributes Name class( stencil_type ), intent(in) :: self Return Value real public pure elemental function get_lower (self) Arguments Type Intent Optional Attributes Name class( stencil_type ), intent(in) :: self Return Value real public pure function apply_stencil (self, f, ref) Arguments Type Intent Optional Attributes Name class( stencil_type ), intent(in) :: self real, intent(in) :: f (:) integer, intent(in) :: ref Return Value real public pure function apply_stencil_along (self, f) Arguments Type Intent Optional Attributes Name class( stencil_type ), intent(in) :: self real, intent(in) :: f (:) Return Value real, allocatable, (:)","tags":"","loc":"module/stencil.html"},{"title":"thomas_module – heatcompact3d","text":"Contents Functions thomas Functions public pure function thomas (as, bs, cs, ds) result(x) Arguments Type Intent Optional Attributes Name real, intent(in) :: as (:) real, intent(in) :: bs (:) real, intent(in) :: cs (:) real, intent(in) :: ds (:) Return Value real, allocatable, (:)","tags":"","loc":"module/thomas_module.html"},{"title":"module_field.f90 – heatcompact3d","text":"Contents Modules field Source Code module_field.f90 Source Code module field implicit none type :: field_type !! Implement a 3D scalar field, for instance a temperature field. !! ```f90 !! type(field_type) = afield !! real :: u0(nx, ny, nz), dx !! afield = field_type(u0, dx) !! ``` private real , allocatable :: data (:, :, :) real :: dx !! Discrete mesh spacing contains procedure , public :: nx , ny , nz procedure , public :: is_equal , rhs , dump procedure , private :: field_add_field , field_sub_field , & & field_mul_real generic :: operator ( + ) => field_add_field generic :: operator ( - ) => field_sub_field generic :: operator ( * ) => field_mul_real end type field_type interface field_type module procedure field_constructor end interface field_type contains function field_constructor ( initial , dx ) result ( afield ) real , intent ( in ) :: initial (:, :, :) !! Initial state real , intent ( in ) :: dx !! Spatial mesh spacing type ( field_type ) :: afield allocate ( afield % data , source = initial ) afield % dx = dx end function field_constructor pure integer function nx ( self ) !! Returns domain size in \\mathbf{x} direction class ( field_type ), intent ( in ) :: self nx = size ( self % data , 1 ) end function nx pure integer function ny ( self ) !! Returns domain size in \\mathbf{y} direction class ( field_type ), intent ( in ) :: self ny = size ( self % data , 2 ) end function ny pure integer function nz ( self ) !! Returns domain size in \\mathbf{z} direction class ( field_type ), intent ( in ) :: self nz = size ( self % data , 3 ) end function nz pure logical function is_equal ( self , lhs , tol ) !! Compare two field_type instance based on their data value !! ```f90 !! f1 = field_type(u0, dx) !! f2 = field_type(u0, dx2) !! f1%is_equal(f2) ! true !! ``` class ( field_type ), intent ( in ) :: self !! Right hand side of comparison class ( field_type ), intent ( in ) :: lhs !! Left hand side of comparison real , intent ( in ) :: tol !! Absolute tolerance when comparing !! fields values logical , allocatable :: elmt_is_equal (:, :, :) elmt_is_equal = abs ( self % data - lhs % data ) < tol is_equal = all ( elmt_is_equal ) end function is_equal subroutine dump ( self , file_path , fmt ) !! Write field data to ASCII file class ( field_type ), intent ( in ) :: self character ( * ), intent ( in ) :: file_path !! Relative path to file to output file character ( * ), optional :: fmt !! Format string integer :: fileunit , i , j , k if (. not . present ( fmt )) fmt = 'f8.1' open ( newunit = fileunit , file = file_path , action = 'write' ) do k = 1 , size ( self % data , 3 ) do j = 1 , size ( self % data , 2 ) do i = 1 , size ( self % data , 1 ) write ( fileunit , fmt ) self % data ( i , j , k ) end do end do end do end subroutine dump pure function rhs ( self ) !! Evaluates right hand side of heat equation on a field instance. !!  F(T) = \\Delta T = \\frac{\\partial&#94;2 T}{\\partial x&#94;2} + !! \\frac{\\partial&#94;2 T}{\\partial y&#94;2} + \\frac{\\partial&#94;2 !! T}{\\partial z&#94;2}  !! use differentiate , only : differentiator_type , & & sixth_order_compact_1 , sixth_order_compact_2 class ( field_type ), intent ( in ) :: self real , allocatable :: ddx (:, :, :), ddy (:, :, :), ddz (:, :, :) type ( field_type ) :: rhs integer :: ix , iy , iz real :: dx2 class ( differentiator_type ), allocatable :: differ dx2 = self % dx * self % dx differ = sixth_order_compact_2 () ! Periodic boundaries allocate ( ddx , source = self % data ) do iz = 1 , self % nz () do iy = 1 , self % ny () ddx (:, iy , iz ) = differ % diff ( self % data (:, iy , iz ), dx2 ) end do end do allocate ( ddy , source = self % data ) do iz = 1 , self % nz () do ix = 1 , self % nx () ddy ( ix , :, iz ) = differ % diff ( self % data ( ix , :, iz ), dx2 ) end do end do allocate ( ddz , source = self % data ) do iy = 1 , self % ny () do ix = 1 , self % nx () ddz ( ix , iy , :) = differ % diff ( self % data ( ix , iy , :), dx2 ) end do end do rhs % data = ddx + ddy + ddz rhs % dx = self % dx end function rhs pure type ( field_type ) function field_add_field ( self , afield ) class ( field_type ), intent ( in ) :: self , afield field_add_field % data = self % data + afield % data field_add_field % dx = self % dx end function field_add_field pure type ( field_type ) function field_sub_field ( self , afield ) class ( field_type ), intent ( in ) :: self , afield field_sub_field % data = self % data - afield % data field_sub_field % dx = self % dx end function field_sub_field pure type ( field_type ) function field_mul_real ( self , a ) !! Multiply a `field_type` instance by a `real` number. !! ``` !! f1 = field_type(u0, dx) !! f2 = f1 * 1.3 !! f2%is_equal(field_type(u0 * 1.3, dx)) ! true !! ``` class ( field_type ), intent ( in ) :: self !! Left hand side real , intent ( in ) :: a !! Scalar to multiply field instance with field_mul_real % data = self % data * a field_mul_real % dx = self % dx end function field_mul_real end module field","tags":"","loc":"sourcefile/module_field.f90.html"},{"title":"module_differentiate.f90 – heatcompact3d","text":"Contents Modules differentiate Source Code module_differentiate.f90 Source Code module differentiate !! This module implements differentiation over a one dimensional !! pencil.  It exports concrete derived types !! !! - `differentiator_type` :: periodic differentiation !! - `nonperiodic_differentiator_type` :: non periodic differentiation !! !! Both types provide access to a single type-procedure `diff` that !! performs the differentiation and return the derivative evaluated !! over the input pencil. !! !! Instances of differentiator derived types are created on the !! client side via constructor procedures `<method>_<order>` !! (e.g. `sixth_order_compact_1`). These constructor procedures are !! implemented as a generic interface to concrete constructors for !! the periodic case (no boundary conditions are specified) or the !! noneriodic case (boundary conditions are specified). See module !! `boundary_schemes`. !! !! ``` !! use boundary_schemes, only:: get_dirichlet_4th !! real :: f(:), df(:), dx !! ! ... !! ! ... !! differentiatior = sixth_order_compact_1( & !!      & east = get_dirichlet_4th(), & !!      & west = get_dirichlet_4th(), & !!      & ) !! df = differentiatior%diff(f, dx) !! ``` use stencil , only : stencil_type use boundary_schemes , only : boundary_type , sixth_order_compact_stencil , & & sixth_order_compact_second_stencil use thomas_module , only : thomas implicit none type :: differentiator_type !! Implements differentiation over a periodic stencil. !! `differentiator_type` provides access a a unique type-bound !! procedure `diff` private type ( stencil_type ) :: bulk_stencil !! Differentiation stencil contains procedure , public :: diff => diff_periodic end type differentiator_type type , extends ( differentiator_type ) :: nonperiodic_differentiator_type type ( stencil_type ) :: east_stencils ( 2 ) type ( stencil_type ) :: west_stencils ( 2 ) contains procedure , public :: diff => diff_nonperiodic end type nonperiodic_differentiator_type interface sixth_order_compact_1 module procedure :: sixth_order_compact_1_periodic module procedure :: sixth_order_compact_1_nonperiodic end interface sixth_order_compact_1 interface sixth_order_compact_2 module procedure :: sixth_order_compact_2_periodic module procedure :: sixth_order_compact_2_nonperiodic end interface sixth_order_compact_2 contains pure function sixth_order_compact_1_nonperiodic ( east , west ) type ( boundary_type ), intent ( in ) :: east , west type ( nonperiodic_differentiator_type ) :: sixth_order_compact_1_nonperiodic sixth_order_compact_1_nonperiodic = nonperiodic_differentiator_type ( & & east_stencils = east % first_order_east , & & west_stencils = west % first_order_west , & & bulk_stencil = sixth_order_compact_stencil () & & ) end function sixth_order_compact_1_nonperiodic pure function sixth_order_compact_1_periodic () type ( differentiator_type ) :: sixth_order_compact_1_periodic sixth_order_compact_1_periodic = differentiator_type ( & & bulk_stencil = sixth_order_compact_stencil () & & ) end function sixth_order_compact_1_periodic pure function sixth_order_compact_2_nonperiodic ( east , west ) type ( boundary_type ), intent ( in ) :: east , west type ( nonperiodic_differentiator_type ) :: sixth_order_compact_2_nonperiodic sixth_order_compact_2_nonperiodic = nonperiodic_differentiator_type ( & & east_stencils = east % second_order_east , & & west_stencils = west % second_order_west , & & bulk_stencil = sixth_order_compact_second_stencil () & & ) end function sixth_order_compact_2_nonperiodic pure function sixth_order_compact_2_periodic () type ( differentiator_type ) :: sixth_order_compact_2_periodic sixth_order_compact_2_periodic = differentiator_type ( & & bulk_stencil = sixth_order_compact_second_stencil () & & ) end function sixth_order_compact_2_periodic pure function diff_nonperiodic ( self , f , dx ) result ( df ) !! Apply a differentiation stencil along a one dimensional pencil, !! then apply boundary conditions on both ends. Boundary !! conditions are applied as arrays of type `stencil_type` class ( nonperiodic_differentiator_type ), intent ( in ) :: self real , intent ( in ) :: f (:) real , intent ( in ) :: dx real , allocatable :: df (:), rhs (:), diag (:), lower_diag (:), upper_diag (:) integer :: neast , nwest integer :: ref , i ! do loop counters type ( stencil_type ) :: sten real :: alpha_coeffs neast = size ( self % east_stencils ) nwest = size ( self % west_stencils ) ! Compute rhs assuming periodicity rhs = self % bulk_stencil % apply_along ( f ) ! Fix rhs values near boundaries do ref = 1 , neast sten = self % east_stencils ( ref ) rhs ( ref ) = sten % apply ( f , ref ) end do do i = 1 , nwest sten = self % west_stencils ( i ) ref = size ( f ) - i + 1 rhs ( ref ) = sten % apply ( f , ref ) end do rhs = rhs / dx ! Solve tridiagonal system of equations diag = [( 1. , i = 1 , size ( f ))] ! Both upper and lower diagonals are declared of size n = size(f) ! instead of n-1, out of convenience. Components upper_diag(n) and ! lower_diag(1) will not be accessed by the thomas solver as they ! do not appear in the tridiagonal system. upper_diag = [ & & self % east_stencils % get_upper (), & & ( self % bulk_stencil % get_upper (), i = neast + 1 , size ( f ) - nwest ), & & reverse ( self % west_stencils % get_upper ()) & ] lower_diag = [ & & self % east_stencils % get_upper (), & & ( self % bulk_stencil % get_lower (), i = neast + 1 , size ( f ) - nwest ), & & reverse ( self % west_stencils % get_upper ()) & ] df = thomas ( lower_diag , diag , upper_diag , rhs ) end function diff_nonperiodic pure function diff_periodic ( self , f , dx ) result ( df ) !! Apply a differentiation stencil along a one dimensional pencil, !! assuming periodic boundaries. For instance, with a four point !! stencil s = (-2, -1, 1, 2) and weights {g_{i}}_{1 \\leq i !! \\leq 4} !! !!  g(1) = g_1f_{n-2} + g_2f_{n-1} + g_3f_{2} + g_4f_{3}  !!  g(2) = g_1f_{n-1} + g_2f_{1} + g_3f_{3} + g_4f_{4}  !! !!  g(i) = g_1f_{i-2} + g_2f_{i-1} + g_3f_{i+1} + g_4f_{i+2}, i = 3, n-2 !! !!  g(n-1) = g_1f_{n-3} + g_2f_{n-2} + g_3f_{n} + g_4f_{2}  !!  g(n) = g_1f_{n-2} + g_2f_{n-1} + g_3f_{2} + g_4f_{3}  class ( differentiator_type ), intent ( in ) :: self real , intent ( in ) :: f (:) !! Function to be derive, evaluated on pencil real , allocatable :: df (:) !! Derivative, evaluated on pencil real , intent ( in ) :: dx !! Step size real , allocatable :: rhs (:), diag (:), lower_diag (:), upper_diag (:) real , allocatable :: u (:), v (:), q (:), y (:) real :: gamma , up , low integer :: nx , i rhs = self % bulk_stencil % apply_along ( f ) rhs = rhs / dx ! Solve quasi-tridiagonal system of equations using the ! Shermann-Morrison formula up = self % bulk_stencil % get_upper () low = self % bulk_stencil % get_lower () gamma = - 1. nx = size ( f ) diag = [ & & 1. - gamma , & & ( 1. , i = 2 , nx - 1 ), & & 1. - ( up * low ) / gamma & & ] ! Both upper and lower diagonals are declared of size n = size(f) ! instead of n-1, out of convenience. Components upper_diag(n) and ! lower_diag(1) will not be accessed by the thomas solver as they ! do not appear in the tridiagonal system. nx = size ( f ) lower_diag = [( low , i = 1 , nx )] upper_diag = [( up , i = 1 , nx )] u = [ gamma , ( 0. , i = 2 , nx - 1 ), up ] v = [ 1. , ( 0. , i = 2 , nx - 1 ), low / gamma ] q = thomas ( lower_diag , diag , upper_diag , u ) y = thomas ( lower_diag , diag , upper_diag , rhs ) df = y - (( y ( 1 ) - low * y ( nx )) & & / ( 1. + q ( 1 ) - low * q ( nx ))) * q end function diff_periodic pure function reverse ( x ) real , intent ( in ) :: x (:) real , allocatable :: reverse (:) reverse = x ( size ( x ): 1 : - 1 ) end function reverse end module differentiate","tags":"","loc":"sourcefile/module_differentiate.f90.html"},{"title":"module_time_integration.f90 – heatcompact3d","text":"Contents Modules time_integrator Source Code module_time_integration.f90 Source Code module time_integrator use field , only : field_type implicit none type , abstract :: time_integrator_type real :: starttime , endtime , dt contains procedure ( integrate_proc ), public , & & deferred :: integrate end type time_integrator_type type , extends ( time_integrator_type ) :: euler_integrator_type real :: alpha = 1. contains procedure :: integrate => integrate_euler end type euler_integrator_type type , extends ( time_integrator_type ) :: AB2_integrator_type contains procedure :: integrate => integrate_AB2 end type AB2_integrator_type type , extends ( time_integrator_type ) :: RK3_integrator_type contains procedure :: integrate => integrate_RK3 end type RK3_integrator_type abstract interface subroutine integrate_proc ( self , afield ) import time_integrator_type , field_type class ( time_integrator_type ), intent ( in ) :: self type ( field_type ), intent ( inout ) :: afield end subroutine integrate_proc end interface contains subroutine integrate_euler ( self , afield ) class ( euler_integrator_type ), intent ( in ) :: self type ( field_type ), intent ( inout ) :: afield integer :: nt integer :: i nt = floor (( self % endtime - self % starttime ) / self % dt ) do i = 1 , nt afield = euler_timestep ( afield , self % dt ) end do end subroutine integrate_euler subroutine integrate_AB2 ( self , afield ) class ( AB2_integrator_type ), intent ( in ) :: self type ( field_type ), intent ( inout ) :: afield type ( field_type ) :: fields ( 2 ) integer :: nt integer :: i nt = floor (( self % endtime - self % starttime ) / self % dt ) fields ( 1 ) = afield fields ( 2 ) = euler_timestep ( afield , self % dt ) do i = 2 , nt fields = AB2_timestep ( fields , self % dt ) end do afield = fields ( 2 ) end subroutine integrate_AB2 subroutine integrate_RK3 ( self , afield ) class ( RK3_integrator_type ), intent ( in ) :: self type ( field_type ), intent ( inout ) :: afield type ( field_type ) :: afield2 integer :: nt , i nt = floor (( self % endtime - self % starttime ) / self % dt ) do i = 1 , nt ! First fractional step is Euler like afield2 = afield % rhs () * ( 8. / 1 5. ) * self % dt + afield ! Second and third steps are AB2 like afield = afield2 % rhs () * ( 5. / 1 2. ) * self % dt & & + afield % rhs () * ( - 1 7. / 6 0. ) * self % dt + afield2 afield = afield % rhs () * ( 3. / 4. ) * self % dt & & + afield2 % rhs () * ( - 5. / 1 2. ) * self % dt + afield end do end subroutine integrate_RK3 pure function euler_timestep ( afield , dt ) result ( res ) type ( field_type ), intent ( in ) :: afield real , intent ( in ) :: dt type ( field_type ) :: res res = afield % rhs () * dt + afield end function euler_timestep pure function AB2_timestep ( fields , dt ) result ( res ) type ( field_type ), intent ( in ) :: fields ( 2 ) real , intent ( in ) :: dt type ( field_type ) :: res ( 2 ) type ( field_type ) :: f1 , f2 f1 = fields ( 1 ) f2 = fields ( 2 ) res ( 2 ) = f2 % rhs () * 1.5 * dt - f1 % rhs () * 0.5 * dt + f2 res ( 1 ) = f2 end function AB2_timestep end module time_integrator","tags":"","loc":"sourcefile/module_time_integration.f90.html"},{"title":"module_boundary_schemes.f90 – heatcompact3d","text":"Contents Modules boundary_schemes Source Code module_boundary_schemes.f90 Source Code module boundary_schemes use stencil , only : stencil_type implicit none type boundary_type type ( stencil_type ) :: first_order_east ( 2 ), second_order_east ( 2 ) type ( stencil_type ) :: first_order_west ( 2 ), second_order_west ( 2 ) end type boundary_type real , parameter :: sixth_order_compact_coeffs ( 4 ) = [ & & - 1. / 3 6. , & & - 7. / 9. , & & + 7. / 9. , & & + 1. / 3 6. & & ] real , parameter :: sixth_order_compact_coeffs_2 ( 5 ) = [ & & 3. / 4 4. , & & 1 2. / 1 1. , & & - 2. * ( 1 2. / 1 1. + 3. / 4 4. ), & & 1 2. / 1 1. , & & 3. / 4 4. & & ] contains pure type ( stencil_type ) function sixth_order_compact_stencil () sixth_order_compact_stencil = stencil_type ( & & nodes = [ - 2 , - 1 , 1 , 2 ], & & coeffs = sixth_order_compact_coeffs , & & upper = 1. / 3. , & & lower = 1. / 3. & & ) end function sixth_order_compact_stencil pure type ( stencil_type ) function sixth_order_compact_second_stencil () sixth_order_compact_second_stencil = stencil_type ( & & nodes = [ - 2 , - 1 , 0 , 1 , 2 ], & & coeffs = sixth_order_compact_coeffs_2 , & & upper = 2. / 1 1. , & & lower = 2. / 1 1. & & ) end function sixth_order_compact_second_stencil type ( boundary_type ) function get_dirichlet_boundary () type ( stencil_type ) :: first_order_east ( 2 ), second_order_east ( 2 ) type ( stencil_type ) :: first_order_west ( 2 ), second_order_west ( 2 ) first_order_east ( 1 ) = stencil_type ( & & nodes = [ 0 , 1 , 2 , 3 ], & & coeffs = [ - 5. / 2. , 2. , 0.5 , 0. ], & & lower = 0. , upper = 2. & & ) first_order_east ( 2 ) = stencil_type ( & & nodes = [ - 1 , 0 , 1 , 2 ], & & coeffs = [ - 3. / 4. , 0. , 3. / 4. , 0. ], & & lower = 1. / 4. , upper = 1. / 4. & & ) second_order_east ( 1 ) = stencil_type ( & & nodes = [ 0 , 1 , 2 , 3 ], & & coeffs = [ 1 3. , - 2 7. , 1 5. , - 1. ], & & lower = 0. , upper = 1 1. & & ) second_order_east ( 2 ) = stencil_type ( & & nodes = [ - 1 , 0 , 1 , 2 ], & & coeffs = [ 6. / 5. , - 1 2. / 5. , 6. / 5. , 0. ], & & lower = 1. / 1 0. , upper = 1. / 1 0. & & ) first_order_west = first_order_east % flip () * ( - 1. ) second_order_west = second_order_east % flip () get_dirichlet_boundary = boundary_type ( & & first_order_east , second_order_east , first_order_west , second_order_west ) end function get_dirichlet_boundary end module boundary_schemes","tags":"","loc":"sourcefile/module_boundary_schemes.f90.html"},{"title":"module_stencil.f90 – heatcompact3d","text":"Contents Modules stencil Source Code module_stencil.f90 Source Code module stencil implicit none type :: stencil_type integer , allocatable :: nodes (:) real , allocatable :: coeffs (:) real :: lower , upper contains procedure , private :: stencil_mul_real procedure , public :: apply => apply_stencil procedure , public :: apply_along => apply_stencil_along procedure , public :: get_upper , get_lower procedure , public :: flip , is_equal generic :: operator ( * ) => stencil_mul_real end type stencil_type contains pure logical function is_equal ( self , st , tol ) class ( stencil_type ), intent ( in ) :: self type ( stencil_type ), intent ( in ) :: st real , intent ( in ) :: tol logical nodes_equal , coeffs_equal nodes_equal = all ( self % nodes == st % nodes ) coeffs_equal = all ( abs ( self % coeffs - st % coeffs ) < tol ) is_equal = nodes_equal . and . coeffs_equal end function is_equal pure elemental type ( stencil_type ) function stencil_mul_real ( self , a ) class ( stencil_type ), intent ( in ) :: self real , intent ( in ) :: a stencil_mul_real = stencil_type ( & & nodes = self % nodes , & & coeffs = a * self % coeffs , & & lower = self % lower , upper = self % upper & & ) end function stencil_mul_real pure elemental type ( stencil_type ) function flip ( self ) class ( stencil_type ), intent ( in ) :: self flip = stencil_type ( & & nodes = - self % nodes , & & coeffs = self % coeffs , & & lower = self % lower , upper = self % upper & & ) end function flip pure elemental real function get_upper ( self ) class ( stencil_type ), intent ( in ) :: self get_upper = self % upper end function get_upper pure elemental real function get_lower ( self ) class ( stencil_type ), intent ( in ) :: self get_lower = self % lower end function get_lower pure real function apply_stencil ( self , f , ref ) class ( stencil_type ), intent ( in ) :: self real , intent ( in ) :: f (:) integer , intent ( in ) :: ref real , allocatable :: eval (:) eval = f ( self % nodes + ref ) apply_stencil = dot_product ( eval , self % coeffs ) end function apply_stencil pure function apply_stencil_along ( self , f ) class ( stencil_type ), intent ( in ) :: self real , intent ( in ) :: f (:) real , allocatable :: apply_stencil_along (:), f_padded (:), eval (:) integer :: ref , i , lpad , rpad lpad = minval ( self % nodes ) + 1 rpad = size ( f ) + maxval ( self % nodes ) allocate ( f_padded ( lpad : rpad )) do i = lpad , 0 f_padded ( i ) = f ( size ( f ) + i - 1 ) end do do i = size ( f ) + 1 , rpad f_padded ( i ) = f ( i - size ( f ) + 1 ) end do f_padded ( 1 : size ( f )) = f allocate ( apply_stencil_along , source = f ) do ref = 1 , size ( f ) ! Would be nice to reuse self%apply_stencil here but any ! negative indices are lost when passing f_padded eval = f_padded ( self % nodes + ref ) apply_stencil_along ( ref ) = dot_product ( eval , self % coeffs ) end do end function apply_stencil_along end module stencil","tags":"","loc":"sourcefile/module_stencil.f90.html"},{"title":"module_thomas.f90 – heatcompact3d","text":"Contents Modules thomas_module Source Code module_thomas.f90 Source Code module thomas_module implicit none contains pure function thomas ( as , bs , cs , ds ) result ( x ) real , intent ( in ) :: as (:), bs (:), cs (:), ds (:) real , allocatable :: x (:), b (:), d (:) integer :: i , n real :: w allocate ( d , source = ds ) allocate ( b , source = bs ) allocate ( x , source = ds ) n = size ( ds ) do i = 2 , n w = as ( i ) / b ( i - 1 ) b ( i ) = b ( i ) - w * cs ( i - 1 ) d ( i ) = d ( i ) - w * d ( i - 1 ) end do x ( n ) = d ( n ) / b ( n ) do i = n - 1 , 1 , - 1 x ( i ) = ( d ( i ) - cs ( i ) * x ( i + 1 )) / b ( i ) end do end function thomas end module thomas_module","tags":"","loc":"sourcefile/module_thomas.f90.html"}]}